#!/bin/sh
#
# A collection of useful functions to bootstrap Smeueg's personal dotfiles
# TODO: Add gruvbox gtk theme
#       (also modify configure_lightdm() to support it as well)


selected_tab=1
selected_opt=1


# UTILS #
err() { printf "\033[1;31m|\033[0m %b\n" "$1" >&2; }
note() { printf "\033[1;32m|\033[0m %b\n" "$1"; }
warn() { printf "\033[1;33m|\033[0m %b\n" "$1"; }

if ! [ "$(command -v dd)" ] || ! [ "$(command -v stty)" ]; then
	err "'dd' and 'stty' are required for this script to run"
	exit 1
fi

# Asks the user $1 (a Y/n question), if $2 is provided, print $2 if it the
# user's reply wasn't a yes
ask() {
	printf "%b [\033[1;32mY\033[0m/\033[1;31mn\033[0m] " "$1"
	read reply
	printf '\033[A\033[2K'
	case ${reply} in
		[Yy][Ee][Ss]|[Yy]|"") return 0;;
		*) [ "$2" ] && note "$2"; return 1;;
	esac
}


# Uses curl or wget to download $1 to $2
fetch() {
	if [ "$(command -v curl)" ]; then
		curl -Ls "$1" -o "$2"
	else
		wget -q "$1" -O "$2"
	fi
}


# Read 1 character
read_char() {
	tty_settings=$(stty -g)
	stty -icanon -echo
	char=$(dd ibs=1 count=1 2>&1)
	char=${char%${char#?}}
	stty "${tty_settings}"
}

newline="
"


# Declaring options. The format is as follows:
# == HEADER ==
# Name1         | func1
# Name2         | func2
if ! [ -w / ]; then
	while read -r line; do
		opts="${opts}${line}${newline}"
	done <<-EOF
	== Rice ==
	Dotfiles             | get_dotfiles
	Font (JetBrainsMono) | get_font
	EOF
else
	msg="You are running this with root privilages, are you sure?"
	msg="${msg} (This will also change the available options)"
	ask "${msg}" || exit 0
	while read -r line; do
		opts="${opts}${line}${newline}"
	done <<-EOF
	== System ==
	Mount tmpfs to /tmp | mktmpfs
	Create Swapfile     | mkswapfile
	Configure LightDM   | configure_lightdm
	EOF
fi


str_controls=""
while read -r line; do
	str_controls="${str_controls}${line}${newline}"
done <<-EOF
\033[1;33mh\033[0m/\033[1;33m←\033[0m: Select previous tab
\033[1;33mj\033[0m/\033[1;33m↓\033[0m: Move down
\033[1;33mk\033[0m/\033[1;33m↑\033[0m: Move up
\033[1;33ml\033[0m/\033[1;33m→\033[0m: Select next tab
\033[1;33mEnter\033[0m: Press
EOF


get_dotfiles() {
	if [ "$1" ]; then
		[ "$(command -v git)" ] || printf "Requires 'git'\n"
		return
	fi

	note "Getting Dotfiles"
	dot_dir="${HOME}/.local/dots/"
	dot_url="https://github.com/Smeueg/Dotfiles.git"

	if [ -d "${dot_dir}" ]; then
		ask "'${dot_dir}' already exists, overwrite?" \
			"Will not overwrite '${dot_dir}'" ||
			return 1
	fi

	# Clones and configures the repo
	git clone --progress --bare --depth 1 "${dot_url}" "${dot_dir}" || return 1
	git --git-dir="${dot_dir}" config status.showUntrackedFiles no || return 1

	# Backup files that already exists
	files=$(git --git-dir="${dot_dir}" ls-tree --full-tree --name-only -r HEAD)
	for file in ${files}; do
		if [ -f "${HOME}/${file}" ]; then
			dot_backup_dir="${HOME}/DotBackups/${file%/*}"
			mkdir -pv "${dot_backup_dir}" &&
				mv -v "${HOME}/${file}" "${dot_backup_dir}"
		fi
	done

	git --git-dir="${dot_dir}" --work-tree="${HOME}" checkout
}


get_font() {
	if [ "$1" ]; then
		{ [ "$(command -v curl)" ] || [ "$(command -v wget)" ]; } ||
			printf "Requires 'curl' or 'wget'\n"
		return
	fi

	note "Getting Fonts"
	font_dir="${HOME}/.local/share/fonts/JetBrainsMono Nerd Font/"
	font_url="https://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/JetBrainsMono/Ligatures"
	mkdir -pv "${font_dir}" || return 1

	for line in $(fetch "${font_url}" -); do
		[ "${line}" ] || continue
		[ "${line##*/tree/master/patched-fonts/JetBrainsMono/Ligatures/*}" ] &&
			continue
		group=${line%\"*}
		group=${group##*/}
		url="https://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/JetBrainsMono/Ligatures/${group}/complete"
		for line in $(fetch "${url}" -); do
			[ "${line}" ] || continue
			[ "${line##*Complete*Mono.ttf*}" ] && continue
			line=${line#*\"}
			line=${line%\"*}
			printf " - Getting %s\n" "${group}"
			url="https://github.com${line%/blob/*}/raw/${line#*/blob/}"
			fetch "${url}" "${font_dir}/JetBrainsMono Nerd Font ${group}.ttf"
		done
	done
}


mktmpfs() {
	if [ "$1" ]; then
		[ -f /etc/fstab ] || { printf "'/etc/fstab' not found\n"; return; }
		[ -w / ] || { printf "Requires root privilages\n"; return; }
		# Check in /etc/fstab
		while read -r line; do
			[ "${line}" ] || continue
			[ "${line%%*tmpfs */tmp *tmpfs*}" ] && continue
			printf "Already in '/etc/fstab'\n"
			return
		done < /etc/fstab
		return
	fi

	note "Adding entry '/etc/fstab' (tmpfs in '/tmp', 512 Mb)"
	printf "tmpfs /tmp tmpfs rw,nodev,nosuid,size=512M 0 0\n" >> /etc/fstab
}


mkswapfile() {
	if [ "$1" ]; then
		if ! [ "$(command -v swapon)" ]; then
			printf "Command 'swapon' not found\n"
			return
		fi
		if ! [ "$(command -v mkswap)" ]; then
			printf "Command 'mkswap' not found\n"
			return
		fi
		[ -w / ] || { printf "Requires root privilages\n"; return; }
		[ -f /swapfile ] && { printf "'/swapfile' already exists\n"; return; }
	fi

	note "Creaing and mounting swapfile (as '/swapfile', 1024 Mb)"
	dd if=/dev/zero of=/swapfile bs=1M count=1024 status=progress
	chmod 0600 /swapfile
	mkswap -U clear /swapfile
	swapon /swapfile
	printf "/swapfile none swap defaults 0 0\n" >> /etc/fstab
}


configure_lightdm() {
	if [ "$1" ]; then
		if ! [ -f /etc/lightdm/lightdm-gtk-greeter.conf ]; then
			printf "LightDM GTK Greeter not installed\n"
			return
		fi
		[ -w / ] || { printf "Requires root privilages\n"; return; }
		return
	fi

	printf "[greeter]\nbackground = #282828\n" > /etc/lightdm/lightdm-gtk-greeter.conf
}


# UI #
ui_setup() {
	while read -r line; do
		[ "${line}" ] || continue
		if [ "${line##== * ==}" ]; then
			func=${line##*\| }
			msg=$(${func} 1)
			line=${line%\|*}
			line=${line%${line##*[^ ]}}
			if [ "${msg}" ]; then
				printf "\033[31m[ ] %s %s\033[0m|%s\n" \
					   "${line}" \
					   "[${msg}]" \
					   "${func}"
				len=$((${#line}))
			else
				printf "[ ] %s|%s\n" "${line}" "${func}"
				len=$((${#line}))
			fi
		else
			printf "%s\n" "${line}"
		fi
	done <<-EOF
	${opts}
	EOF
}


ui_get_max() {
	max=0
	while read -r line; do
		line=${line%\|*}
		line=${line%$(printf "\033[0m")}
		line=${line#$(printf "\033[31m")}
		[ ${#line} -gt ${max} ] && max=${#line}
	done <<-EOF
	${opts}
	EOF
}


ui_set_tablist() {
	str_tab=
	i=0
	while read -r line; do
		[ "${line#== * ==}" ] && continue
		line=${line#== }
		line=${line% ==}
		space=

		while [ ${#space} -ne ${#line} ]; do
			space="${space} "
		done

		i=$((i + 1))
		if [ ${i} -eq ${selected_tab} ]; then
			str_tab="${str_tab}\033[A┬\033[B\033[D│ \033[1;33m${line}\033[0m "
			str_tab="${str_tab}\033[A┬\033[B\033[D│"
			str_tab="${str_tab}\033[B\033[${#line}D\033[4D┘ ${space} └"
			str_tab="${str_tab}\033[A"
		else
			str_tab="${str_tab}\033[A┬\033[2B\033[D┴\033[D\033[A│ ${line} │"
			str_tab="${str_tab}\033[A\033[D┬\033[2B\033[D┴\033[A"
		fi
	done <<-EOF
	${opts}
	EOF
}


ui_set_border() {
	border=
	i=0
	while [ ${i} -ne ${max} ]; do
		border="${border}─"
		i=$((i + 1))
	done
}


ui_display() {
	printf "%s\n\n" "┌${border}┐"
	printf "%s\n" "├${border}┤"
	printf "\033[2A%*s │\r%b\n\n" ${max} "" "│${str_tab}"
	i_tab=0
	i_opt=0
	while read -r line; do
		if ! [ "${line##== * ==}" ]; then
			i_tab=$((i_tab + 1))
			[ ${i_tab} -eq ${selected_tab} ] &&
				i_opt=0
			continue
		fi
		[ ${i_tab} -eq ${selected_tab} ] || continue

		i_opt=$((i_opt + 1))
		if [ ${i_opt} -eq ${selected_opt} ]; then
			printf "%*s │\r│\033[7m%b\033[0m\n" ${max} "" "${line%\|*}"
		else
			printf "%*s │\r│%b\n" ${max} "" "${line%\|*}"
		fi
	done <<-EOF
	${opts}
	EOF

	if [ ${selected_opt} -eq $((i_opt + 1)) ]; then
		printf "%s\r\033[2C\033[7m Continue \033[0m\n" "└${border}┘"
	else
		printf "%s\r\033[2C Continue \n" "└${border}┘"
	fi
}


ui_select(){
	i_tab=0
	i_opt=0
	while read -r line; do
		if ! [ "${line##== * ==}" ]; then
			i_tab=$((i_tab + 1))
			[ ${i_tab} -eq ${selected_tab} ] &&
				i_opt=0
			printf "%s\n" "${line}"
			continue
		fi
		if ! [ ${i_tab} -eq ${selected_tab} ]; then
			printf "%b\n" "${line}"
			continue
		fi
		i_opt=$((i_opt + 1))

		if [ ${i_opt} -eq ${selected_opt} ]; then
			if ! [ "${line%%*$(printf '\033[31m\n')*}" ]; then
				printf "%b\n" "${line}"
			elif [ "${line##*\[ \]*}" ]; then
				printf "%b\n" "${line%%\[X\]*}[ ]${line#*\[X\]}"
			else
				printf "%b\n" "${line%%\[ \]*}[X]${line#*\[ \]}"
			fi
		else
			printf "%s\n" "${line}"
		fi
		done <<-EOF
	${opts}
	EOF
}


printf "%b" "${str_controls}"
opts=$(ui_setup)
ui_get_max
ui_set_tablist
ui_set_border
while true; do
	ui_display
	read_char

	case ${char} in
		h) selected_tab=$((selected_tab - (selected_tab != 1)))
		   ui_set_tablist
		   ;;
		j) selected_opt=$((selected_opt + (selected_opt != i_opt + 1))) ;;
		k) selected_opt=$((selected_opt - (selected_opt != 1))) ;;
		l) selected_tab=$((selected_tab + (selected_tab != i_tab)))
		   ui_set_tablist
		   ;;
		q) printf "%b\033[9A\r\033[J" "\033[${i_opt}A"
		   exit
		   ;;
		${newline})
			[ ${selected_opt} -eq $((i_opt + 1)) ] && break
			opts=$(ui_select)
			selected_opt=$((selected_opt + (selected_opt != i_opt)))
			;;
	esac
	printf "%b\033[4A\r\033[J" "\033[${i_opt}A"
done

printf "%b\033[944A\r\033[J" "\033[${i_opt}A"

while read -r line; do
	[ "${line%%\[X\]*}" ] && continue
	${line##*\|}
done <<-EOF
${opts}
EOF
