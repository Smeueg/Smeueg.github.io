#!/bin/sh
# Variables #

newline="
"

selected_tab=1
selected_opt=1

# Helper Functions #
error() { printf "\033[1;31m|\033[0m%s\n" "${@}" >&2; }
notice() { printf "\033[1;32m|\033[0m%s\n" "${@}"; }

# Asks ${1} and prompts for a Y/n answer
ask() {
	printf "\033[33m|\033[0m%b\033[0m" "${1}"
	printf " [\033[1;32mY\033[0m/\033[1;31mn\033[0m] "
	read -r line
	case ${line} in
		""|[Yy][Ee][Ss]|[Yy]) return 0 ;;
		*) return 1 ;;
	esac
}


# Splits ${1} with ${2} as its delimiter
split() {
	set -f
	O_IFS=${IFS}
	IFS=${2}
	set -- ${1}
	printf '%s\n' "${@}"
	IFS=${O_IFS}
	set +f
}


# Replaces every character in ${1} with ${2}
replace() {
	i=${#1}
	str=""
	while [ ${i} -gt 0 ]; do
		i=$((i - 1))
		str="${str}${2}"
	done
	printf '%s\n' "${str}"
}

# Prints ${1}, ${2} times
dup() {
	i=${2}
	str=""
	while [ ${i} -gt 0 ]; do
		i=$((i - 1))
		str="${str}${1}"
	done
	printf '%s\n' "${str}"
}

# Tries to run ${@}, else prints an error message and returns
try() {
	if ! "${@}"; then
		error "Failed to run: ${*}"
		return 1
	fi
}

if [ "$(command -v curl)" ]; then
	fetch() { curl -Ls "${1}" -o "${2}"; }
elif [ "$(command -v wget)" ]; then
	fetch() { wget --no-hsts "${1}" -O "${2}"; }
fi


# UI Functions #
# Setups the options (Dependency checking)
opts_setup() {
	for line in ${1}; do
		if ! [ "${line##== * ==}" ]; then
			printf '%s\n' "${line}"
			continue
		fi

		# Gets the label/name
		label=${line%%\[*}
		label=${label%${label##*[^ ]}}

		# Gets missing dependencies
		dep_missing=""
		deps=${line##*\[}
		deps=${deps%%\]*}
		for dep in $(split "${deps}" ","); do
			if ! [ "${dep##*|*}" ]; then
				run=false
				for dep_optional in $(split "${dep}" "|"); do
					if [ "$(command -v "${dep_optional}")" ]; then
						run=true
						break
					fi
				done
				${run} || dep_missing="${dep_missing} ${dep}"
			else
				[ "$(command -v "${dep}")" ] ||
					dep_missing="${dep_missing} ${dep}"
			fi
		done
		dep_missing=${dep_missing# }

		if [ "${dep_missing}" ]; then
			dep_missing=" [Requires: ${dep_missing}]"
			label="[-] ${label}"
		else
			label="[ ] ${label}"
		fi
		line="${label}${dep_missing} |${line##*\|}"

		printf '%b\n' "${line}"
	done
}


# Prints the UI
opts_print() {
	O_IFS=${IFS}
	IFS=${newline}
	str_tab=""
	str_choices=""
	counter_opt=0
	counter_tab=0
	width=0
	continue="Continue"
	for line in ${1}; do
		# Creates the tab string
		if ! [ "${line##== * ==}" ]; then
			counter_tab=$((counter_tab + 1))
			line=${line#== }
			line=${line% ==}

			if [ ${counter_tab} -eq ${selected_tab} ]; then
				str_tab="${str_tab}\033[1;33m ${line} \033[0m"
				str_tab="${str_tab}\033[${#line}D\033[3D\033[B╯ "
				str_tab="${str_tab}$(replace "${line}" ' ') ╰\b\033[A"
			else
				str_tab="${str_tab} ${line} "
				str_tab="${str_tab}\033[B┴\033[A\b"
			fi
			str_tab="${str_tab}\033[A┬\033[B\b│"
			str_tab_char_count=$((str_tab_char_count + ${#line} + 1))
			continue
		fi
		[ ${counter_tab} -ne ${selected_tab} ] && continue
		counter_opt=$((counter_opt + 1))
		# Creates the choices string
		line=${line%% | *}
		[ ${#line} -gt ${width} ] && width=${#line}
		[ "${line%%\[-\] *}" ] || line="\033[1;31m${line}\033[0m"
		[ ${counter_opt} -eq ${selected_opt} ] && line="\033[7m${line}\033[0m"
		str_choices="${str_choices}${line}${newline}"
	done

	str_width=$(dup "─" "${width}")
	printf '╭┬%s\b╮\033[B\b│\033[A\n\n├┴%s\b┤\r\033[A' "${str_width}" "${str_width}"
	printf '││%b\n\n' "${str_tab}"

	# Prints the choices
	[ ${selected_opt} -gt ${counter_opt} ] &&
		continue="\033[7m${continue}\033[0m"
	for line in ${str_choices}; do
		printf "%$((width + 1))s│\r│%b\n" "" "${line}"
	done
	printf '╰%s╯\r\033[2C %b \n' "${str_width}" "${continue}"
	printf "\033[%sA\033[4A" "${counter_opt}"
	IFS=${O_IFS}
}


# Select/Deselect chosen option
opts_select() {
	O_IFS=${IFS}
	IFS=${newline}
	counter_tab=0
	counter_opt=0

	for line in ${1}; do
		if ! [ "${line##== * ==}" ]; then
			counter_tab=$((counter_tab + 1))
			counter_opt=0
			printf '%s\n' "${line}"
			continue
		fi
		counter_opt=$((counter_opt + 1))

		if [ ${counter_tab} -eq ${selected_tab} ] && [ ${counter_opt} -eq ${selected_opt} ]; then
			if ! [ "${line%%\[ \]*}" ]; then
				printf '[*]%s\n' "${line#\[ \]}"
			elif ! [ "${line%%\[\*\]*}" ]; then
				printf '[ ]%s\n' "${line#\[\*\]}"
			else
				printf '%s\n' "${line}"
			fi
		else
			printf '%s\n' "${line}"
		fi
	done
	IFS=${O_IFS}
}


# Runs installs/run the chosen options
opts_run() {
	for line in ${1}; do
		[ "${line##== * ==}" ] || continue
		[ "${line%%\[ \]*}" ] || continue
		"${line##*| }"
	done
}



# Install Functions #
get_dotfiles() {
	dot_dir="${HOME}/.local/dots/"
	dot_url="https://github.com/Smeueg/Dotfiles.git"
	# Confirms to overwrite an already existing repo if it exists
	notice "Getting Dotfiles"
	if [ -d "${dot_dir}" ]; then
		if ! ask "'\033[35m${dot_dir}\033[0m' already exists, overwrite?"; then
			printf 'Will not overwrite\n'
			return 1
		else
			rm -rf "${dot_dir}"
		fi
	fi

	# Clones and configures the repo
	try git clone --progress --bare --depth 1 "${dot_url}" "${dot_dir}" ||
		return 1
	try git --git-dir="${dot_dir}" config status.showUntrackedFiles no ||
		return 1

	# Backup files that already exists
	for file in $(git --git-dir="${dot_dir}" ls-tree --full-tree --name-only -r HEAD); do
		if [ -f "${HOME}/${file}" ]; then
			dot_backup_dir="${HOME}/DotBackups/${file%/*}"
			mkdir -pv "${dot_backup_dir}" && mv -v "${HOME}/${file}" "${dot_backup_dir}"
		fi
	done
	try git --git-dir="${dot_dir}" --work-tree="${HOME}" checkout "${HOME}"
}


get_font() {
	font_dir="${HOME}/.local/share/fonts/"
	font_dir="${font_dir%/}/JetBrainsMono Nerd Font"

	# Create directory if doesn't exist and return if failed to create directory
	mkdir -pv "${font_dir}" || return 1

	notice "Downloading fonts"
	url="https://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/JetBrainsMono/Ligatures"
	for line in $(fetch "${url}" -); do
		[ "${line}" ] || continue
		[ "${line##*/ryanoasis/nerd-fonts/tree/master/patched-fonts/JetBrainsMono/Ligatures/*}" ] && continue
		group=${line%\"*}
		group=${group##*/}
		url="https://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/JetBrainsMono/Ligatures/${group}/complete"
		for subline in $(fetch "${url}" -); do
			[ "${subline}" ] || continue
			[ "${subline##*Complete*Mono.ttf*}" ] && continue
			subline=${subline#*href=\"}
			subline=${subline%\"*}
			printf ' - Getting %s\n' "${group}"
			fetch "https://github.com${subline%/blob/*}/raw/${subline#*/blob/}" "${font_dir%/}/JetBrainsMono Nerd Font ${group} Complete.ttf"
		done
	done
}


mktmpfs() {
	notice "Mounting tmpfs with a size of 512M to /etc/fstab"
	if ! [ -f "/etc/fstab" ]; then
		error "/etc/fstab doesn't exist"
		return 1
	fi

	while IFS= read -r line; do
		[ "${line}" ] || continue
		[ "${line%%tmpfs*/tmp*tmpfs*}" ] && continue
		error "'/tmp' is already mounted as tmpfs" >&2
		return 1
	done < /etc/fstab

	if ! ask "Continue?"; then
		printf "Won't add tmpfs to /etc/fstab\n"
		return
	fi
	notice "Adding tmpfs to '/etc/fstab'"
	printf "tmpfs /tmp tmpfs rw,nodev,nosuid,size=512M 0 0\n" >> /etc/fstab
}


mkswapfile() {
	notice "Creating swapfile at '/swapfile' (1024 MiB)\n"

	[ -f "/swapfile" ] && ! ask "'/swapfile' already exists, overwrite?" &&
		return 1

	dd if=/dev/zero of=/swapfile bs=1M count=1024 status=progress
	chmod 0600 /swapfile
	mkswap -U clear /swapfile
	swapon /swapfile
	printf "/swapfile none swap defaults 0 0\n" >> /etc/fstab
}


# Main Code #
if [ "${BASH}" ]; then
	read_c() { read -rn1 char; }
elif [ "$(command -v stty)" ] && [ "$(command -v dd)" ]; then
	read_c() {
		tty_settings=$(stty -g)
		stty -icanon
		char=$(dd ibs=1 count=1 2>&1)
		char=${char%${char#?}}
		stty "${tty_settings}"
	}
else
	error "This scripts has to either be run with 'bash', or 'stty' and 'dd' has to be installed"
	exit 1
fi

if ! [ -w / ]; then
	opts="
== Rice ==
Dotfiles              [git,mv]     | get_dotfiles
Font (JetBrainsMono)  [wget|curl]  | get_font"
else
	ask "You are running this script with elevated permisions, do you want to continue?"
	opts="
== System ==
Mount tmpfs to /tmp   [sudo|su]                         | mktmpfs
Create Swapfile       [sudo|su,mkswap,swapon,dd,chmod]  | mkswapfile"
fi


trap "printf '\r\033[J'; exit 130" INT
opts=$(IFS=${newline} opts_setup "${opts}")
while true; do
	IFS=${newline} opts_print "${opts}"
	read_c
	printf '\r\033[J'
	# Controls

	if [ "${char}" = "$(printf '\033')" ]; then
		read_c
		read_c
		case ${char} in
			"A") char="k" ;;
			"B") char="j" ;;
			"C") char="l" ;;
			"D") char="h" ;;
		esac
	fi

	case ${char} in
		""|"${newline}")
			if [ ${selected_opt} -gt ${counter_opt} ]; then
				printf '\033[A\033[J'
				break
			fi
			opts=$(opts_select "${opts}");
			selected_opt=$((selected_opt+(selected_opt!=counter_opt)))
			printf '\033[A'
			;;
		"h") selected_tab=$((selected_tab-(selected_tab!=1)));;
		"j") selected_opt=$((selected_opt+(selected_opt<=counter_opt)));;
		"k") selected_opt=$((selected_opt-(selected_opt!=1)));;
		"l") selected_tab=$((selected_tab+(selected_tab!=counter_tab)));;
		"q") exit 0 ;;
	esac
done


IFS=${newline} opts_run "${opts}"
