#!/bin/sh

# Colors
cl_green="\033[1;32m"
cl_red="\033[1;31m"
cl_yellow="\033[1;33m"
cl_blue="\033[1;34m"
cl_magenta="\033[1;35m"
cl_cyan="\033[1;36m"
cl_reset="\033[0m"
y_or_n="[${cl_green}y${cl_reset}/${cl_red}N${cl_reset}]"

# Helper Functions
if [ "${COLUMNS+x}" ]; then
	get_cols() { COLUMNS=${COLUMNS}; }
else
	get_cols() { COLUMNS=$(stty size); COLUMNS=${COLUMNS#* }; }
fi
notice() { printf "[${cl_green}NOTICE${cl_reset}] %s\n" "${1}"; }
error() {
	printf "[${cl_red}ERROR${cl_reset}] %s\n" "${1}" >&2
	exit 1
}

replace() {
	# Replace ${1} with ${2} in the variable ${3}
	str=${3}
	while ! [ "${str%%*${1}*}" ]; do
	 	str="${str%%${1}*}${2}${str#*${1}}"
	done
	printf '%s\n' "${str}"
	unset str
}


header() {
	i=0
	get_cols
	while [ ${i} -ne ${COLUMNS} ]; do
		str="${str}â”€"
		i=$((i+1))
	done
	printf '${cl_red}%s${cl_reset}' "${str}"
	[ "${1}" ] &&
		printf "\r\033[$(((COLUMNS - ${#1} - 2) / 2))C ${1} \n"
	unset str
}


# Dependencies
[ "$(command -v youtube-dl)" ] || error "'youtube-dl' isn't installed"
[ "$(command -v ffmpeg)" ] || error "'ffmpeg' isn't installed"


# Prompt for playlist url
printf "Insert playlist url (Default is Smeueg's personal playlist): "
read reply
if ! [ "${reply}" ]; then
	pl_url="https://www.youtube.com/playlist?list=PLRV1hc8TIW-7znQIWaVarxdUxf7lskmBc"
elif [ "${reply%%https://www.youtube.com/playlist\?list=*}" ]; then
	error "Invalid URL: ${reply}"
else
	pl_url=${reply}
	printf '\033[A\r\033[2K\r'
fi


# Prompt for where to download the playlist (a directory)
printf "Insert target directory (Default is '~/Music/'): "
read reply
if [ "${reply}" ]; then
	[ -d "${reply}" ] || error "Directory ${reply} doesn't exist"
	music_dir=${reply}
else
	music_dir="${HOME}/Music"
fi


# Ask whether to remove songs that don't exist
printf "Remove local songs that aren't in the playlist? ${y_or_n} "
read reply
case ${reply} in
	[Yy][Ee][Ss]|[Yy]) remove=true ;;
	*) remove=false ;;
esac

if ${remove}; then
	cl_remove="${cl_green}"
else
	cl_remove="${cl_red}"
fi


# Get playlist title
printf "Getting playlist title, please wait..."
pl_title=$(youtube-dl --playlist-end 1 -o "%(playlist)s" --get-filename "${pl_url}")
printf "\r"


# Overview for final confirmation
overview="\
\033[3A\033[J${cl_yellow}Overview${cl_reset}
* ${cl_cyan}Playlist${cl_reset}:
  - ${cl_blue}Title${cl_reset}: ${pl_title}
  - ${cl_blue}URL${cl_reset}: ${pl_url}
* ${cl_cyan}Target Directory${cl_reset} : ${music_dir}
* ${cl_cyan}Remove Songs${cl_reset}     : ${cl_remove}${remove}${cl_reset}
Are you sure? ${y_or_n} "
printf '%b' "${overview}"
read reply
case ${reply} in
	[Yy][Ee][Ss]|[Yy]) ;;
		*) exit 0;;
	esac


	# Exit if "${music_dir}" doesn't exist and can't be created
if ! [ -d "${music_dir}" ]; then
	mkdir -pv "${music_dir}" || exit 1
fi



get_title_id() {
	youtube-dl "${pl_url}" --flat-playlist --get-id -e |
		{
			while { read -r title; read id; }; do
				title=$(IFS="/" replace "\\" "${title}")
				title=$(replace "/" "\\" "${title}")
				tmp="${tmp}${title}:${id}${newline}"
			done
			printf '%s\n' "${tmp}"
		}
}


sync_download() {
	# Download song's that aren't downloaded yet
	header "Downloading Songs"
	ran=false
	for line in ${output}; do
		title=${line%:*}
		url="https://www.youtube.com/watch?v=${line##*:}"
		if ! [ -f "${music_dir%/}/${title}.mp3" ]; then
			ran=:
		   	youtube-dl "${url}" \
					   -x \
		 			   --audio-format mp3 \
		 			   --add-metadata --metadata-from-title "%(title)s" \
		 			   --postprocessor-args \
		 			   "-acodec libmp3lame" \
		 			   -o "${music_dir}/${title}.%(ext)s"
		fi
	done
	${ran} || printf 'No songs need to be downloaded\n'
	header
}


sync_remove() {
	# Remove song's that aren't in the playlist anymore
	printf '\n\n'
	header "Removing Songs No Longer In The Playlist"
	ran=false
	for file in "${music_dir%/}"/*; do
		file=${file#${music_dir%/}/}

		for line in ${output}; do
			[ "${line%:*}.mp3" = "${file}" ] && continue 2
		done
		ran=:
		rm -v "${music_dir%/}/${file}"
	done
	${ran} || printf 'No files to remove\n'
	header
}


newline="
"

output=$(get_title_id)
IFS=${newline} sync_download
${remove} && IFS=${newline} sync_remove
printf '\n'
